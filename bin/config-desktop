#!/usr/bin/env perl

package EnvConf;
use 5.02000;
use utf8;
use warnings;
use feature qw/signatures/;
no warnings qw/experimental::signatures/;

use File::Path qw/make_path remove_tree/;
use File::Basename qw/basename dirname/;
use File::Spec::Functions qw/catdir/;
use File::Copy qw/copy move/;
use File::Temp qw/:seekable/;
use Getopt::Long;
use Carp qw/croak carp/;
use Cwd qw/realpath/;
use File::HomeDir;
use Readonly;
use YAML::Tiny;
use Readonly;
use Pod::Usage;
use Env qw/HOME/;

Readonly::Scalar my $BASE_PATH => dirname dirname realpath __FILE__;

sub new {
  my $class = shift;

  my @vars = qw/CHI_COD_DIR CHI_ENV_DIR PERL_CPANM_HOME
		PERLBREW_ROOT/;

  for my $var (@vars) {
    unless (exists $ENV{$var}) {
      croak "Environment variable `$var' is not set.";
    }
  }

  my $self = {
	      'unwanted-dirs' => [],
	      'wanted-dirs' => [],
	      'files-to-link' => {},
  };

  my $parser = Getopt::Long::Parser->new;
  $parser->configure (qw/bundling no_ignore_case/);
  my %options = (
		 'config-file' => catdir ($BASE_PATH,
					  'config-options.yml'),
		 verbose => 0,
		 force => 0,
		 help => 0,
  );

  my $status = $parser->getoptions ('verbose|v' => \$options{verbose},
		       'force|f' => \$options{force},
		       'config-file|c=s' => \$options{'config-file'},
                       'help|h' => \$options{help},);

  pod2usage 1 if delete $options{help};
  pod2usage 2 unless $status;

  my $doc= YAML::Tiny->read (delete $options{'config-file'});
  $self->{doc} = $doc->[0]->{'config-desktop'};
  $self->{$_} = $options{$_} for keys %options;

  bless $self, $class;
}

sub setup_unwanted_files {
  my $self = shift;

  for my $config_options (@{$self->{doc}->[0]->{'config-desktop'}}) {
    for my $element (@{$config_options->{'unwanted-files'}}) {
      $element = catdir (File::HomeDir->my_home, $element);
      push @{$self->{'unwanted-files'}}, $element;
    }
  }
}

sub get_variable {
  my ($self, $str) = @_;
  if ($str =~ m|(?<var_fake_name>\$(?<var_real_name>\w+)\$)|) {
    my ($fake_name, $real_name) = (quotemeta ($+{var_fake_name}),
				   $+{var_real_name},);
    if (exists $ENV{$real_name} && defined $ENV{$real_name}) {
      my $real_path = $ENV{$real_name};
      $real_path =~ s|~/|$HOME/|;
      return {
	      'value' => $real_path,
	      'quoted-name' => $fake_name,
      };
    }
    else {
      carp "Environment variable `$real_name' does not exist.";
      return;
    }
  }
  else {
    return 1;
  }
}

sub setup_targets_and_links {
  my $self = shift;

  for my $ref (@{$self->{doc}->[2]->{'files-to-link'}}) {
    for my $file (keys %{$ref}) {
      my ($src_path, $dst_path)= ($file, $ref->{$file});
      my $src_path_info = $self->get_variable ($file);

      next unless defined $src_path_info;

      if (ref $src_path_info) {
	$src_path =~
	  s|$src_path_info->{'quoted-name'}|$src_path_info->{value}|;
      }
      else {
	$src_path = catdir $BASE_PATH, $file;
      }

      my $dst_path_info = $self->get_variable ($dst_path);
      next unless defined $dst_path_info;

      if (ref $dst_path_info) {
	$dst_path =~
	  s|$dst_path_info->{'quoted-name'}|$dst_path_info->{value}|;
      }

      if ($dst_path =~ m|(?<invisible>_)?self$|) {
	my $name = basename $src_path;
	$name = ".$name" if defined $+{invisible};

	$dst_path =~ s|(_?self$)|$name|;
      }
      elsif ($dst_path =~
	       m%(?<invisible>^_|(?<sep>/)_)(?<name>\w+$)%) {

	my ($invisible, $name, $sep) = ($+{invisible}, $+{name},
					$+{sep});
	if (defined $invisible && defined $sep) {
	  $dst_path =~ s%/_$name%/.$name%;
	}
	else {
	  $dst_path =~ s!_$name!.$name!;
	}
      }

      unless ($dst_path =~ m|^/|) {
	$dst_path = catdir (File::HomeDir->my_home, $dst_path);
      }

      ${$self->{'files-to-link'}}{$src_path} = $dst_path;
    }
  }
}

sub setup_wanted_dirs {
  my $self = shift;
  for my $item (@{$self->{doc}->[1]->{'wanted-dirs'}}) {
    my $path_info = $self->get_variable ($item);

    next unless defined $path_info;

    if (ref $path_info) {
      push @{$self->{'wanted-dirs'}}, $path_info->{value};
    }
    else {
      push @{$self->{'wanted-dirs'}}, catdir (File::HomeDir->my_home,
					      $item);
    }
  }
}

sub run {
  my $self = shift;

  $self->setup_unwanted_files;
  $self->setup_targets_and_links;
  $self->setup_wanted_dirs;

  $self->pre_configure;
  $self->configure;
}

sub pre_configure {
  my $self = shift;

  for my $dir (@{$self->{'wanted-dirs'}}) {
    my $shortname = $self->filename_shortify ($dir);

    if (-d $dir && $self->{verbose}) {
      say "File: `$shortname' exists. Nothing will be done." if $self->{verbose};
    }
    else {
      make_path $dir;
      say "Created `$shortname'..." if $self->{verbose};
    }
  }

  for my $file (@{$self->{'unwanted-files'}}) {
    my $shortname = $self->filename_shortify ($file);
    if (-d $file) {
     remove_tree $file;
      say "Removed `$shortname'...";
    }
    elsif (-f $file) {
     unlink $file if -f $file;
      say "Removed `$shortname'";
    }
  }

  my @dirs;
  push @dirs, catdir (File::HomeDir->my_home, '.ssh');
  while (my $dir = pop @dirs) {
    opendir (my $DIR_HANDLE, $dir);
    while (my $dir_entry = readdir $DIR_HANDLE) {
      next if $dir_entry eq '..' || $dir_entry eq '.';
      my $shortname = $self->filename_shortify ($dir_entry);
      $dir_entry = catdir $dir, $dir_entry;
      my $perm_mode = (stat $dir_entry)[2] & 0777;
      if (-f $dir_entry) {
        if ($perm_mode != 0600) {
	  chmod 0600, $dir_entry;
	  if ($self->{verbose}) {
	    say "Fixed permissions of \'$shortname\' to 0600";
	  }
        }
      }
      elsif (-d $dir_entry) {
        if ($perm_mode != 0700) {
	  chmod 0700, $dir_entry;
	  if ($self->{verbose}) {
	    say "Fixed premissions of \'$shortname\' to 0700";
	  }
        }
        push @dirs, $dir_entry;
      }
    }
    closedir $DIR_HANDLE;
  }
}

sub filename_shortify {
  my ($self, $file) = @_;

  my $home = File::HomeDir->my_home;

  $file =~ s|$home|~|;

  return $file;
}

sub configure {
  my $self = shift;

  if ($self->{force}) {
    for my $src (keys %{$self->{'files-to-link'}}) {
      my $dest = ${$self->{'files-to-link'}}{$src};
      my $shortname = $self->filename_shortify ($dest);
      if (-f $dest) {
        unlink $dest;

        say "Removed file `$shortname'." if $self->{verbose};
      }
      elsif (-d $dest) {
        remove_tree $dest;
        say "Removed directory `$shortname'." if $self->{verbose};
      }
    }
  }

  my %ftl = %{$self->{'files-to-link'}};
  while (my ($file, $link) = each %ftl) {
    my $shortname = $self->filename_shortify ($link);
    if (-l $link) {
      my $target = readlink $link;
      next if $target eq $file && !$self->{force};
      unlink $link;
      say "Removed link: `$shortname'." if $self->{verbose};
    }
    elsif (-f $link) {
      unlink $link;
      say "Removed file: `$shortname'." if $self->{verbose};
    }
    elsif (-d $link) {
      remove_tree $link;
      say "Removed directory: `$shortname'." if $self->{verbose};
    }

    if (! -e $link || $self->{force}) {
      symlink $file, $link;
      say "Created symlink: `$shortname'." if $self->{verbose};
    }
  }

  my $zeal_conf_file = catdir $ENV{HOME}, '.config', 'Zeal',
                              'Zeal.conf';
  my $docset_dir = catdir $ENV{CHI_SHARE_DIR}, 'zeal', 'docset';

  return unless -f $zeal_conf_file;
  my $tmp = File::Temp->new (CLEANUP => 1,
			     TMPDIR => 1,
			     TEMPLATE => 'dc-artifact-XXXXXXX',
			     SUFFIX => '.conf');
  copy $zeal_conf_file, $tmp->filename;
  $tmp->seek (0, SEEK_SET);
  open (my $ZEAL_FH, '>', $zeal_conf_file);
  while (my $line = $tmp->getline ()) {
    chomp $line;
    $line =~ s|path=.*|path=$docset_dir|;
    say {$ZEAL_FH} $line;
  }
}

package main;

EnvConf->new->run;

BEGIN {

}

__END__

=head1 NAME

Configure my openSuse desktop.

=head1 SYNOPSIS

config-desktop [OPTIONS]

Options:
  --help, -h             Print this help message.

  --verbose, -v          Be verbose.

  --force, -f            Force re-link of files.

  --config-file, -c      A YAML file with configurations.

=cut
